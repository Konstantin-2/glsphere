<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Гексагональная сетка</title>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.7.1.js"></script>
    <script src="https://code.jquery.com/ui/1.14.1/jquery-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
            integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
            crossorigin="anonymous"
            defer></script>
    <script>
        function main() {
            /* Точки должны быть против частовой стрелки со стороны наблюдателя
             * Ось Z направлена от экрана к зрителю */
            "use strict"
            const timerInterval = 50;

            class Vertex {
                constructor() {
                    this.pos = vec3.create();
                    this.normal = vec3.create();
                    this.color = vec3.create();
                }

                static fromCoords(x, y, z) {
                    const v = new Vertex();
                    vec3.set(v.pos, x, y, z);
                    return v;
                }

                static fromVec3(from) {
                    const v = new Vertex();
                    v.pos = vec3.clone(from);
                    return v;
                }

                static fromVec3Color(from, color) {
                    const v = new Vertex();
                    v.pos = vec3.clone(from);
                    v.color = color;
                    return v;
                }

                pos;
                normal;
                color;
            }

            class Mesh {
                constructor() {
                    this.vertices = [];
                    this.indices = [];
                }

                addBuffer(src) {
                    this.vertices = this.vertices.concat(src.vertices);
                }

                addVertexByGeocoords(lat, lon, h) {
                    this.vertices.push(Vertex.fromCoords(
                        h * Math.cos(lat) * Math.cos(lon),
                        h * Math.sin(lat),
                        h * Math.cos(lat) * Math.sin(lon)
                    ));
                }

                addVertex(v, color) {
                    this.vertices.push(Vertex.fromVec3Color(v, color));
                }

                autoNormals() {
                    let d1 = vec3.create();
                    let d2 = vec3.create();
                    let c = vec3.create();
                    for (let i = 0; i + 2 < this.vertices.length; i += 3) {
                        vec3.sub(d1, this.vertices[i].pos, this.vertices[i + 1].pos);
                        vec3.sub(d2, this.vertices[i].pos, this.vertices[i + 2].pos);
                        vec3.cross(c, d1, d2);
                        vec3.normalize(c, c);
                        const res = vec3.clone(c);
                        this.vertices[i].normal = res;
                        this.vertices[i + 1].normal = res;
                        this.vertices[i + 2].normal = res;
                    }
                }

                setColor(r, g, b) {
                    const vcolor = vec3.fromValues(r, g, b);
                    for (let i = 0; i < this.vertices.length; i++)
                        this.vertices[i].color = vcolor;
                }

                scale(a) {
                    for (let i = 0; i < this.vertices.length; i++)
                        vec3.scale(this.vertices[i].pos, this.vertices[i].pos, a);
                }

                move(dx, dy, dz) {
                    const d = vec3.fromValues(dx, dy, dz);
                    for (let i = 0; i < this.vertices.length; i++)
                        vec3.add(this.vertices[i].pos, this.vertices[i].pos, d);
                }

                printDistance(i1, i2) {
                    const d = vec3.create();
                    vec3.sub(d, this.vertices[i1].pos, this.vertices[i2].pos);
                    const l = vec3.len(d);
                    console.log(`distance [${i1}][${i2}]=${l}`);
                }

                printPoints() {
                    for (let i = 0; i < this.vertices.length; i++) {
                        const v = this.vertices[i].pos;
                        console.log(`pt${i}: ${v[0]};${v[1]};${v[2]}`);
                    }
                }

                /** @type {Vertex[]} */
                vertices;
                /** @type {integer[]} */
                indices;
            }

            class FBOdepth {
                constructor(gl) {
                    this.width = 2048;
                    this.height = 2048;
                    this.texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, this.texture);
                    const level = 0;
                    const border = 0;
                    const data = null;
                    const internalFormat = gl.DEPTH_COMPONENT32F;
                    const format = gl.DEPTH_COMPONENT;
                    const type = gl.FLOAT;
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                        this.width, this.height, border,
                        format, type, data);

                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
                    this.fbo = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.texture, level);
                }

                texture;
                fbo;
                width;
                height;
            }

            class ProgramGl {
                constructor(gl) {
                    this.gl = gl;
                }

                loadShader(type, source) {
                    const shader = this.gl.createShader(type);
                    this.gl.shaderSource(shader, source);
                    this.gl.compileShader(shader);
                    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                        console.error(`An error occurred compiling the shaders: ${this.gl.getShaderInfoLog(shader)}`);
                        this.gl.deleteShader(shader);
                        return null;
                    }
                    return shader;
                }

                initShaderProgram(vsSource, fsSource) {
                    const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, vsSource);
                    const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, fsSource);
                    const shaderProgram = this.gl.createProgram();
                    this.gl.attachShader(shaderProgram, vertexShader);
                    this.gl.attachShader(shaderProgram, fragmentShader);
                    this.gl.linkProgram(shaderProgram);
                    if (!this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS)) {
                        console.error(`Unable to initialize the shader program: ${this.gl.getProgramInfoLog(shaderProgram)}`);
                        return null;
                    }
                    return shaderProgram;
                }
            }

            class ProgramDepth extends ProgramGl {
                constructor(gl) {
                    super(gl);
                    const vsSource = `#version 300 es
                precision highp float;
                layout (location = ${Frame.layPositions}) in vec4 pos;
                uniform mat4 lightMatrix;
                uniform mat4 modelMatrix;

                void main(void)
                {
                    gl_Position = lightMatrix * modelMatrix * pos;
                }`;
                    const fsSource = `#version 300 es
                    precision highp float;
                    out vec4 fragColor;
                    void main() {
                        fragColor = vec4(1.0, 1.0, 1.0, 1.0);
                }`;

                    this.program = this.initShaderProgram(vsSource, fsSource);
                    this.lightMatrix = gl.getUniformLocation(this.program, "lightMatrix");
                    this.modelMatrix = gl.getUniformLocation(this.program, "modelMatrix");
                }

                preexec(frame) {
                    this.gl.uniformMatrix4fv(this.lightMatrix, false, frame.lightMatrix);
                    this.gl.uniformMatrix4fv(this.modelMatrix, false, frame.modelMatrix);
                }
            }

            class ProgramColors extends ProgramGl {
                constructor(gl) {
                    super(gl);
                    const vsSource = `#version 300 es
                    precision highp float;
                    layout (location = ${Frame.layPositions}) in vec4 pos;
                    layout (location = ${Frame.layNormals}) in vec4 normal;
                    layout (location = ${Frame.layColors}) in vec4 vcolor;
                    uniform mat4 pMatrix;
                    uniform mat4 lightMatrix;
                    uniform mat4 normalMatrix;
                    uniform mat4 modelMatrix;
                    uniform vec3 vLight;
                    out vec4 shadowCoord;
                    out vec4 color;
                    out float light;
                    void main(void) {
                      gl_Position = pMatrix * modelMatrix * pos;
                      shadowCoord = lightMatrix * modelMatrix * pos;
                      vec4 transformedNormal = normalMatrix * modelMatrix * normal;
                      light = max(dot(transformedNormal.xyz, vLight), 0.0);
                      color = vcolor;
                    }`;
                    const fsSource = `#version 300 es
                    precision highp float;
                    in vec4 shadowCoord;
                    in vec4 color;
                    in float light;
                    uniform highp sampler2DShadow shadowMap;
                    out vec4 fragColor;
                    const float ambient = 0.2;
                    void main(void) {
                        vec4 tmp = shadowCoord;
                        vec3 shadcoords = tmp.xyz / tmp.w * 0.5 + 0.5;
                        shadcoords.z -= 0.005;
                        float hit;
                        if (shadowCoord.x >= -1.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= -1.0 && shadowCoord.y <= 1.0)
                            hit = texture(shadowMap, shadcoords) * light * (1.0 - ambient) + ambient;
                        else
                            hit = light * (1.0 - ambient) + ambient;
                        fragColor = vec4(color.xyz * hit, 1.0);
                    }`;

                    this.program = this.initShaderProgram(vsSource, fsSource);
                    this.pMatrix = gl.getUniformLocation(this.program, "pMatrix");
                    this.normalMatrix = gl.getUniformLocation(this.program, "normalMatrix");
                    this.vLight = gl.getUniformLocation(this.program, "vLight");
                    this.shadowMap = gl.getUniformLocation(this.program, "shadowMap");
                    this.lightMatrix = gl.getUniformLocation(this.program, "lightMatrix");
                    this.modelMatrix = gl.getUniformLocation(this.program, "modelMatrix");
                    gl.useProgram(this.program);
                }

                preexec(frame) {
                    this.gl.uniformMatrix4fv(this.pMatrix, false, frame.pMatrix);
                    this.gl.uniform3fv(this.vLight, frame.vLight);
                    this.gl.uniformMatrix4fv(this.normalMatrix, true, frame.normalMatrix);
                    this.gl.uniformMatrix4fv(this.lightMatrix, false, frame.lightMatrix);
                    this.gl.uniformMatrix4fv(this.modelMatrix, false, frame.modelMatrix);
                    this.gl.activeTexture(this.gl.TEXTURE0);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, frame.fbodepth.texture);
                    this.gl.uniform1i(this.shadowMap, 0); // 0 because gl.TEXTURE_0_
                }
            }

            class ProgramBlack extends ProgramGl {
                constructor(gl) {
                    super(gl);
                    const vsSource = `#version 300 es
                    precision highp float;
                    layout (location = ${Frame.layPositions}) in vec4 pos;
                    uniform mat4 pMatrix;
                    uniform mat4 modelMatrix;
                    void main(void) {
                      gl_Position = pMatrix * modelMatrix * pos;
                    }`;
                    const fsSource = `#version 300 es
                    precision highp float;
                    out vec4 fragColor;
                    void main(void) {
                        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    }`;

                    this.program = this.initShaderProgram(vsSource, fsSource);
                    this.pMatrix = gl.getUniformLocation(this.program, "pMatrix");
                    this.modelMatrix = gl.getUniformLocation(this.program, "modelMatrix");
                    gl.useProgram(this.program);
                }

                preexec(frame) {
                    this.gl.uniformMatrix4fv(this.pMatrix, false, frame.pMatrix);
                    this.gl.uniformMatrix4fv(this.modelMatrix, false, frame.modelMatrix);
                }
            }

            class Frame {
                constructor(id, cb_animate_id, cb_shapes_id, divider_id, new_id, height_id) {
                    const that = this;
                    const canvas = document.getElementById(id);
                    this.gl = canvas.getContext("webgl2");
                    if (this.gl === null) {
                        const p = document.createElement("p")
                        p.innerText = "Unable to initialize WebGL. Your browser or machine may not support it.";
                        p.style.color = "red";
                        canvas.parentNode.insertBefore(p, canvas);
                        return;
                    }
                    this.gl.clearColor(0.9, 0.9, 1.0, 1.0);
                    this.gl.clearDepth(1.0);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                    this.gl.enable(this.gl.DEPTH_TEST);
                    this.gl.depthFunc(this.gl.LEQUAL);
                    this.gl.enable(this.gl.CULL_FACE);

                    this.program_d = new ProgramDepth(this.gl);
                    this.program_c = new ProgramColors(this.gl);
                    this.program_b = new ProgramBlack(this.gl);
                    this.pMatrix = mat4.create();
                    this.normalMatrix = mat4.create();

                    const light_hangle = Math.PI / 3;
                    const light_vangle = Math.PI / 6;
                    const vec3null = vec3.fromValues(0.0, 0.0, 0.0);
                    this.vLight = vec3.fromValues(0.0, 0.0, 1.0);
                    vec3.rotateX(this.vLight, this.vLight, vec3null, -light_vangle);
                    vec3.rotateY(this.vLight, this.vLight, vec3null, -light_hangle);
                    vec3.normalize(this.vLight, this.vLight);

                    this.lightMatrix = mat4.create();
                    mat4.ortho(this.lightMatrix, -1, 1, -1, 1, -2, 1);
                    mat4.rotate(this.lightMatrix,
                        this.lightMatrix,
                        light_vangle,
                        [1.0, 0.0, 0.0]
                    );
                    mat4.rotate(this.lightMatrix,
                        this.lightMatrix,
                        light_hangle,
                        [0.0, 1.0, 0.0]
                    );

                    this.fbodepth = new FBOdepth(this.gl);
                    this.seed = new Seed();
                    this.scale = 1;
                    this.hangle = 0;
                    this.vangle = 0;
                    this.modelMatrix = mat4.create();
                    this.mouse = {}

                    const cb_shapes = document.getElementById(cb_shapes_id);
                    const cb_frame = document.getElementById(cb_animate_id);
                    this.divider = document.getElementById(divider_id);
                    this.height = document.getElementById(height_id);
                    cb_shapes.addEventListener("change", function () {
                        that.shapes = cb_shapes.checked;
                        that.draw();
                    });
                    this.shapes = cb_shapes.checked;

                    cb_frame.addEventListener("change", function (e) { that.animate(e.target.checked); });
                    canvas.addEventListener('mousedown', (event) => { that.onMouseDown(event); });
                    canvas.addEventListener('mousemove', (event) => { that.onMouseMove(event); });
                    canvas.addEventListener('mouseup', (event) => { that.onMouseUp(event); });
                    canvas.addEventListener('mouseout', (event) => { that.onMouseOut(event); });
                    canvas.addEventListener('wheel', (event) => { that.onMouseWheel(event); event.preventDefault(); });
                    canvas.frame = this;
                    document.getElementById(new_id)?.addEventListener("click", function () {
                        that.seed.random();
                        that.load();
                        that.draw();
                    });

                    this.divider.addEventListener("change", function () {
                        that.load();
                        that.draw();
                    });
                    this.height.addEventListener("change", function () {
                        that.load();
                        that.draw();
                    });
                    if (cb_frame.checked)
                        this.animate(true);
                    this.inited = true;
                }

                init() {
                    this.seed.random();
                    this.load();
                    this.onresize();
                }

                load() { // create map, mesh, load data to GPU
                    const N = parseInt(this.divider.value);
                    const coresize = parseFloat(this.height?.value) ?? 1;
                    this.map = new Map(N);
                    const mesh = this.createMesh(coresize);
                    const vertices = mesh.vertices;
                    this.vertices_cnt = mesh.vertices.length;
                    this.indices_cnt = mesh.indices.length;
                    let tmpbuf = [];
                    for (let i = 0; i < vertices.length; i++)
                        tmpbuf.push(
                            vertices[i].pos[0], vertices[i].pos[1], vertices[i].pos[2],
                            vertices[i].normal[0], vertices[i].normal[1], vertices[i].normal[2],
                            vertices[i].color[0], vertices[i].color[1], vertices[i].color[2],
                        );
                    const array = new Float32Array(tmpbuf);

                    if (!this.g_vertices)
                        this.g_vertices = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.g_vertices);
                    this.gl.bufferData(this.gl.ARRAY_BUFFER, array, this.gl.STATIC_DRAW);
                    setAttribute(this.gl, Frame.layPositions);
                    setAttribute(this.gl, Frame.layNormals);
                    setAttribute(this.gl, Frame.layColors);

                    if (!this.g_indices)
                        this.g_indices = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.g_indices);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.indices), this.gl.STATIC_DRAW);

                    function setAttribute(gl, ptr) {
                        const bytes_per_float = Float32Array.prototype.BYTES_PER_ELEMENT;
                        gl.vertexAttribPointer(
                            ptr,
                            3, // pull out 3 values per iteration
                            gl.FLOAT,
                            false, // don't normalize
                            bytes_per_float * 9, // stride
                            bytes_per_float * 3 * ptr, // offset
                        );
                        gl.enableVertexAttribArray(ptr);
                    }
                }

                draw() {
                    mat4.identity(this.modelMatrix);
                    mat4.rotate(this.modelMatrix,
                        this.modelMatrix,
                        this.vangle,
                        [1.0, 0.0, 0.0]
                    );
                    mat4.rotate(this.modelMatrix,
                        this.modelMatrix,
                        this.hangle,
                        [0.0, 1.0, 0.0]
                    );

                    this.gl.useProgram(this.program_d.program);
                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbodepth.fbo);
                    this.gl.viewport(0, 0, this.fbodepth.width, this.fbodepth.height);
                    this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
                    this.program_d.preexec(this);
                    this.gl.drawArrays(this.gl.TRIANGLES, 0, this.vertices_cnt);

                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
                    this.gl.useProgram(this.program_c.program);
                    this.gl.viewport(0, 0, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                    this.program_c.preexec(this);
                    this.gl.drawArrays(this.gl.TRIANGLES, 0, this.vertices_cnt);
                    if (this.shapes) {
                        this.gl.useProgram(this.program_b.program);
                        this.program_b.preexec(this);
                        this.gl.drawElements(this.gl.LINES, this.indices_cnt, this.gl.UNSIGNED_SHORT, 0);
                    }
                }

                onresize() {
                    this.gl.canvas.width = this.gl.canvas.clientWidth;
                    this.gl.canvas.height = this.gl.canvas.clientHeight;
                    const aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight;

                    if (aspect >= 1)
                        mat4.ortho(this.pMatrix, -aspect, aspect, -1, 1, -10, 10);
                    else
                        mat4.ortho(this.pMatrix, -1, 1, -1 / aspect, 1 / aspect, -10, 10);
                    this.draw();
                }

                animate(run) {
                    const that = this;
                    if (run)
                        this.timer = setInterval(draw, timerInterval);
                    else {
                        clearInterval(this.timer);
                        this.timer = null;
                    }

                    function draw() {
                        that.hangle += Math.PI / (5 * timerInterval);
                        if (that.hangle > 2 * Math.PI)
                            that.hangle -= 2 * Math.PI;
                        that.draw();
                    }
                }

                onMouseDown(event) {
                    this.mouse.down = true;
                    this.mouse.x = event.x;
                    this.mouse.y = event.y;
                    this.mouse.hangle = this.hangle;
                    this.mouse.vangle = this.vangle;
                }

                onMouseUp(event) {
                    this.mouse.down = false;
                    this.processMouseMove(event.x, event.y);
                }

                onMouseOut(event) {
                    this.mouse.down = false;
                }

                onMouseMove(event) {
                    if (this.mouse.down)
                        this.processMouseMove(event.x, event.y);
                }

                onMouseWheel(event) {
                    if (event.deltaY > 0) {
                        this.scale /= 1.1;
                        this.load();
                        this.draw();
                    } else {
                        this.scale *= 1.1;
                        this.load();
                        this.draw();
                    }
                }

                processMouseMove(x, y) {
                    this.hangle = this.mouse.hangle + 2 * (x - this.mouse.x) / this.gl.canvas.width;
                    this.vangle = this.mouse.vangle + 2 * (y - this.mouse.y) / this.gl.canvas.height;
                    this.draw();
                }

                static get layPositions() { return 0; }
                static get layNormals() { return 1; }
                static get layColors() { return 2; }

                // массив в GPU
                g_vertices;
            }

            class Frame1 extends Frame {
                constructor() {
                    super("glcanvas1", "cb_frame1", "cb_shapes1", "divider1", "new1", "height1");
                    if (!this.inited) return;
                    this.scale = 0.95;
                    this.init();
                }

                createMesh(coresize) {
                    const res = new Mesh();
                    const N = this.map.N;
                    this.map.fillHeights(this.seed, coresize);

                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * N; y++)
                            for (let x = 0; x < N; x++) {
                                const coord1 = Map.geoPos(N, l, y, x);
                                const coord2 = Map.geoPos(N, l, y + 1, x);
                                const coord3 = Map.geoPos(N, l, y + 1, x + 1);
                                const coord4 = Map.geoPos(N, l, y, x + 1);
                                const node1 = this.map.byCoords(l, y, x);
                                const node2 = this.map.byCoords(l, y + 1, x);
                                const node3 = this.map.byCoords(l, y + 1, x + 1);
                                const node4 = this.map.byCoords(l, y, x + 1);
                                const h1 = node1.h;
                                const h2 = node2.h;
                                const h3 = node3.h;
                                const h4 = node4.h;
                                res.addVertexByGeocoords(coord1.lat, coord1.lon, h1);
                                res.addVertexByGeocoords(coord2.lat, coord2.lon, h2);
                                res.addVertexByGeocoords(coord3.lat, coord3.lon, h3);
                                res.addVertexByGeocoords(coord1.lat, coord1.lon, h1);
                                res.addVertexByGeocoords(coord3.lat, coord3.lon, h3);
                                res.addVertexByGeocoords(coord4.lat, coord4.lon, h4);
                            }
                    res.indices = [];
                    for (let i = 0; i + 2 < res.vertices.length; i += 3)
                        res.indices.push(i, i + 1, i + 1, i + 2, i + 2, i);
                    res.scale(this.scale);
                    res.autoNormals();
                    res.setColor(0.7, 1, 0.7);
                    return res;
                }
            }

            class Frame2 extends Frame {
                constructor() {
                    super("glcanvas2", "cb_frame2", "cb_shapes2", "divider2", "new2", "height2");
                    if (!this.inited) return;
                    const that = this;
                    this.scale = 0.75;
                    this.grassColor = vec3.fromValues(0.7, 1, 0.7);
                    this.waterColor = vec3.fromValues(0.2, 0.5, 1);
                    this.sandColor = vec3.fromValues(1, 1, 0.5);
                    this.snowColor = vec3.fromValues(1, 1, 1);
                    this.waterLevel = document.getElementById("water2");
                    this.cbWater = document.getElementById("cb_water2");
                    this.waterLevel.addEventListener("change", function (e) {
                        that.load();
                        that.draw();
                    });
                    this.cbWater.addEventListener("change", function (e) {
                        that.load();
                        that.draw();
                    });
                    this.init();
                }

                createMesh(coresize) {
                    const that = this;
                    const res = new Mesh();
                    const N = this.map.N;
                    const waterLevel = parseFloat(this.waterLevel.value) ?? 0;
                    this.map.fillHeights(this.seed, coresize);
                    this.map.fillIds();
                    this.map.fillNeighbors();
                    this.map.fillGeoCoords();
                    fillEdges();
                    draw();
                    res.scale(this.scale);
                    res.autoNormals();
                    //res.setColor(1, 1, 1);
                    return res;

                    function draw() {
                        for (let l = 0; l < 5; l++)
                            for (let y = 0; y < 2 * N; y++)
                                for (let x = 0; x < N; x++)
                                    drawCell(that.map.map[l][y][x]);
                        drawCell(that.map.nord);
                        drawCell(that.map.south);
                        function drawCell(cell) {
                            // рисуем верх и черные линии границ
                            let vl = res.vertices.length;
                            res.indices.push(vl, vl + 1);
                            for (let i = 1; i + 1 < cell.edges.length; i++) {
                                res.addVertex(cell.edges[0][0], cell.color);
                                let vl = res.vertices.length;
                                res.indices.push(vl, vl + 1);
                                res.addVertex(cell.edges[i][0], cell.color);
                                res.addVertex(cell.edges[i + 1][0], cell.color);
                            }
                            res.indices.push(res.vertices.length - 1, vl);

                            for (let i = 0; i < cell.edges.length; i++) {
                                let i1 = i + 1;
                                if (i1 == cell.edges.length) i1 = 0;
                                const v1 = cell.edges[i][0];
                                const v2 = cell.edges[i1][0];
                                const neib = cell.edges[i][1];
                                if (neib.h >= cell.h)
                                    continue;
                                let j = 0;
                                while (j < neib.edges.length && neib.edges[j][1] != cell) j++;
                                const v4 = neib.edges[j][0];
                                j++;
                                if (j == neib.edges.length) j = 0;
                                const v3 = neib.edges[j][0];
                                res.addVertex(v1, cell.color);
                                res.addVertex(v3, cell.color);
                                res.addVertex(v2, cell.color);
                                res.addVertex(v2, cell.color);
                                res.addVertex(v3, cell.color);
                                res.addVertex(v4, cell.color);
                            }
                        }
                    }

                    function fillEdges() {
                        for (let l = 0; l < 5; l++)
                            for (let y = 0; y < 2 * N; y++)
                                for (let x = 0; x < N; x++)
                                    processCell(that.map.map[l][y][x]);
                        processCell(that.map.nord);
                        processCell(that.map.south);

                        function processCell(cell) {
                            if (!that.cbWater.checked)
                                cell.color = that.grassColor;
                            else if (cell.h <= waterLevel) {
                                cell.h = waterLevel;
                                cell.color = that.waterColor;
                            } else if (cell.h <= waterLevel + 0.1)
                                cell.color = that.sandColor;
                            else if (cell.h > waterLevel + 0.5)
                                cell.color = that.snowColor;
                            else
                                cell.color = that.grassColor;

                            // границы. [vec3, node1, node2]
                            const edges = [];
                            const v = geoTo3D(cell.lat, cell.lon);
                            const vh = vec3.create();
                            vec3.scale(vh, v, cell.h);
                            for (let i = 0; i < cell.neighbors.length; i++) {
                                let i1 = i + 1;
                                if (i1 == cell.neighbors.length) i1 = 0;
                                const node1 = cell.neighbors[i];
                                const node2 = cell.neighbors[i1];
                                const v1 = geoTo3D(node1.lat, node1.lon);
                                const v2 = geoTo3D(node2.lat, node2.lon);

                                let m = mat3.fromValues(
                                    v[0], v1[0], v2[0],
                                    v[1], v1[1], v2[1],
                                    v[2], v1[2], v2[2]
                                );
                                let d = vec3.fromValues(1, 1, 1);
                                mat3.invert(m, m);
                                vec3.transformMat3(d, d, m);

                                const t = cell.h / (v[0] * d[0] + v[1] * d[1] + v[2] * d[2]);
                                vec3.scale(d, d, t);
                                edges.push([d, node2]);
                            }
                            cell.edges = edges;
                        }
                    }
                }
            }

            class Frame3 extends Frame {
                constructor() {
                    super("glcanvas3", "cb_frame3", "cb_shapes3", "divider3", "new3", "height3");
                    if (!this.inited) return;
                    this.scale = 0.95;
                    this.init();
                }

                createMesh(coresize) {
                    const res = new Mesh();
                    const N = this.map.N;
                    let v0 = vec3.create();

                    let maxh = 0;
                    for (let l = 0; l < 6; l++)
                        for (let j = 0; j < N; j++)
                            for (let i = 0; i < N; i++) {
                                let x = (i + 0) / N - 0.5;
                                let y = (j + 0) / N - 0.5;
                                let v = vec3.fromValues(x, y, 0.5);

                                switch (l) {
                                    case 1:
                                        vec3.rotateY(v, v, v0, Math.PI / 2);
                                        break;
                                    case 2:
                                        vec3.rotateY(v, v, v0, Math.PI);
                                        break;
                                    case 3:
                                        vec3.rotateY(v, v, v0, -Math.PI / 2);
                                        break;
                                    case 4:
                                        vec3.rotateX(v, v, v0, Math.PI / 2);
                                        break;
                                    case 5:
                                        vec3.rotateX(v, v, v0, -Math.PI / 2);
                                        break;
                                }
                                let h = this.seed.height(v[0], v[1], v[2]);
                                if (maxh < h) maxh = h;
                            }
                    if (maxh == 0) maxh = 1;

                    for (let l = 0; l < 6; l++)
                        for (let j = 0; j < N; j++)
                            for (let i = 0; i < N; i++) {
                                let x1 = (i + 0) / N - 0.5;
                                let x2 = (i + 1) / N - 0.5;
                                let y1 = (j + 0) / N - 0.5;
                                let y2 = (j + 1) / N - 0.5;
                                let v = [
                                    vec3.fromValues(x1, y1, 0.5),
                                    vec3.fromValues(x1, y2, 0.5),
                                    vec3.fromValues(x2, y2, 0.5),
                                    vec3.fromValues(x2, y1, 0.5),
                                ];
                                switch (l) {
                                    case 1:
                                        for (let k = 0; k < 4; k++)
                                            vec3.rotateY(v[k], v[k], v0, Math.PI / 2);
                                        break;
                                    case 2:
                                        for (let k = 0; k < 4; k++)
                                            vec3.rotateY(v[k], v[k], v0, Math.PI);
                                        break;
                                    case 3:
                                        for (let k = 0; k < 4; k++)
                                            vec3.rotateY(v[k], v[k], v0, -Math.PI / 2);
                                        break;
                                    case 4:
                                        for (let k = 0; k < 4; k++)
                                            vec3.rotateX(v[k], v[k], v0, Math.PI / 2);
                                        break;
                                    case 5:
                                        for (let k = 0; k < 4; k++)
                                            vec3.rotateX(v[k], v[k], v0, -Math.PI / 2);
                                        break;
                                }
                                for (let k = 0; k < 4; k++) {
                                    vec3.normalize(v[k], v[k]);
                                    let h = this.seed.height(v[k][0], v[k][1], v[k][2]);
                                    h = coresize + (1 - coresize) * h / maxh;
                                    vec3.scale(v[k], v[k], h);
                                }

                                let vl = res.vertices.length;
                                res.indices.push(vl, vl + 1, vl + 1, vl + 2, vl + 2, vl + 5, vl + 5, vl);

                                res.addVertex(v[0]);
                                res.addVertex(v[3]);
                                res.addVertex(v[2]);
                                res.addVertex(v[0]);
                                res.addVertex(v[2]);
                                res.addVertex(v[1]);
                            }
                    res.scale(this.scale);
                    res.autoNormals();
                    res.setColor(0.7, 1, 0.7);
                    return res;
                }
            }

            class Frame4 extends Frame {
                constructor() {
                    super("glcanvas4", "cb_frame4", "cb_shapes4", "divider4", "new4", "height4");
                    if (!this.inited) return;
                    this.scale = 0.95;
                    this.init();
                }

                createMesh(coresize) {
                    const res = new Mesh();
                    const N = this.map.N;

                    let maxh = 0;
                    for (let j = 0; j <= 2 * N; j++)
                        for (let i = 0; i < 4 * N; i++) {
                            const lat = Math.PI / 2 * j / N - Math.PI / 2;
                            const lon = Math.PI / 2 * i / N;
                            let v = geoTo3D(lat, lon);
                            let h = this.seed.height(v[0], v[1], v[2]);
                            if (maxh < h) maxh = h;
                        }
                    if (maxh == 0) maxh = 1;

                    for (let j = 0; j <= 2 * N; j++)
                        for (let i = 0; i < 4 * N; i++) {
                            const lat1 = Math.PI / 2 * (j + 0) / N - Math.PI / 2;
                            const lat2 = Math.PI / 2 * (j + 1) / N - Math.PI / 2;
                            const lon1 = Math.PI / 2 * (i + 0) / N;
                            const lon2 = Math.PI / 2 * (i + 1) / N;
                            let v = [
                                geoTo3D(lat1, lon1),
                                geoTo3D(lat1, lon2),
                                geoTo3D(lat2, lon2),
                                geoTo3D(lat2, lon1)
                            ];

                            for (let k = 0; k < 4; k++) {
                                let h = this.seed.height(v[k][0], v[k][1], v[k][2]);
                                h = coresize + (1 - coresize) * h / maxh;
                                vec3.scale(v[k], v[k], h);
                            }

                            let vl = res.vertices.length;
                            res.indices.push(vl, vl + 1, vl + 1, vl + 2, vl + 2, vl + 5, vl + 5, vl);

                            res.addVertex(v[0]);
                            res.addVertex(v[3]);
                            res.addVertex(v[2]);
                            res.addVertex(v[0]);
                            res.addVertex(v[2]);
                            res.addVertex(v[1]);
                        }
                    res.scale(this.scale);
                    res.autoNormals();
                    res.setColor(0.7, 1, 0.7);
                    return res;
                }
            }

            /** Карта
             * Узлы, из которых формируется поверхность.
             * Сожержит:
             * - массив map[l][y][x], элементами которого являются Узлы;
             * - две отдельных переменных nord и south, которые тоже являются Узлы;
             * - число N, описывающее размер карты.
             * 0 ≤ y < 2N, 0 ≤ x < N.
             * Узел — информация о точке на карте.
             * Узел может содержать:
             * - высоту, т.е. расстояние от центра (число h);
             * - геокоординаты (числа lon, lat);
             * - список соседей (массив neighbors).
             * Сожержимое Узлов наполняется в зависимости от условий (как именно будет отображаться поверхность). */
            class Map {
                constructor(N) {
                    this.N = N;
                    this.nord = {};
                    this.south = {};
                    const map = this.map = new Array(5);
                    for (let l = 0; l < 5; l++) {
                        const segment = map[l] = new Array(2 * N);
                        for (let y = 0; y < 2 * N; y++) {
                            const row = segment[y] = new Array(N);
                            for (let x = 0; x < N; x++)
                                row[x] = {};
                        }
                    }
                }

                /** Возвращает геокоординаты по прямоугольным координатам.
                 * Для северного полюса используй getPos(N, l, N, 0),
                 * Для южного полюса используй getPos(N, l, 0, 2 * N).
                 * @param {int} N 0 < N
                 * @param {int} l 0 ≤ l < 5
                 * @param {int} y 0 ≤ y ≤ 2N
                 * @param {int} x 0 ≤ x ≤ N
                 */
                static geoPos(N, l, y, x) {
                    // let angle = Math.PI / 6;
                    let angle = Math.PI / 2 - 2 * Math.atan(2 / (1 + Math.sqrt(5)));

                    const lon_shift = l * 2 * Math.PI / 5;
                    if (y < x) {
                        const frac = N - x + y;
                        return {
                            lat: (Math.PI / 2 - angle) * (y - x) / N - angle,
                            lon: frac > 0 ? y * 2 * Math.PI / 5 / frac + lon_shift : 0
                        }

                    }
                    else if (y > x + N) {
                        const frac = 2 * N - y + x;
                        return {
                            lat: (Math.PI / 2 - angle) * (y - x - N) / N + angle,
                            lon: frac > 0 ? x * 2 * Math.PI / 5 / frac + Math.PI / 5 + lon_shift : Math.PI / 5
                        }
                    }
                    else
                        return {
                            lat: 2 * angle * (y - x) / N - angle,
                            lon: (x + y) / N * Math.PI / 5 + lon_shift
                        }
                }

                /** Возвращает узел по его прямоугольным координатам.
                 * Координаты могут на единицу отличаться от нормированных, что используется для поиска соседей узлов, т.е. -1 ≤ y ≤ 2N, -1 ≤ x ≤ N.
                 * @param {int} N 0 < N
                 * @param {int} l 0 ≤ l < 5
                 * @param {int} y 0 ≤ y ≤ 2N
                 * @param {int} x 0 ≤ x ≤ N
                 */
                byCoords(l, y, x) {
                    const N = this.N;
                    if (x == -1) {
                        if (y < N) {
                            l--;
                            x += N;
                            y += N;
                        } else if (y == N && N == 1)
                            return this.nord;
                        else {
                            l--;
                            x = 2 * N - y - 1;
                            y = 2 * N - 1;
                        }
                    } else if (x == N) {
                        if (y == 0)
                            return this.south;
                        else if (y < N) {
                            l++;
                            x = N - y;
                            y = 0;
                        } else {
                            l++;
                            x -= N;
                            y -= N;
                        }
                    } else if (y == -1) {
                        if (x == 0 && N == 1)
                            return this.south;
                        else {
                            l--;
                            y = N - x - 1;
                            x = N - 1;
                        }
                    } else if (y == 2 * N) {
                        if (x == 0)
                            return this.nord;
                        else {
                            l++;
                            y = 2 * N - x;
                            x = 0;
                        }
                    }
                    if (l == -1)
                        l = 4;
                    else if (l == 5)
                        l = 0;
                    return this.map[l][y][x];
                }

                /** Заполняет высоты в узлах
                 * @param {Seed} seed
                 * @param {float} coresize 0 < coresize ≤ 1. Минимальная высота (максимальная = 1).
                 */
                fillHeights(seed, coresize) {
                    const N = this.N;
                    if (coresize == 1) {
                        for (let l = 0; l < 5; l++)
                            for (let y = 0; y < 2 * N; y++)
                                for (let x = 0; x < N; x++)
                                    this.map[l][y][x].h = 1;
                        this.nord.h = 1;
                        this.south.h = 1;
                        return;
                    }

                    // Заполняем высоты, пока не нормированные
                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * N; y++)
                            for (let x = 0; x < N; x++) {
                                const coord = Map.geoPos(N, l, y, x);
                                const xx = Math.cos(coord.lat) * Math.cos(coord.lon);
                                const yy = Math.sin(coord.lat);
                                const zz = Math.cos(coord.lat) * Math.sin(coord.lon);
                                this.map[l][y][x].h = seed.height(xx, yy, zz);
                            }
                    this.nord.h = seed.height(0, 1, 0);
                    this.south.h = seed.height(0, -1, 0);

                    // Ищем максимальную высоту
                    let maxh = 0;
                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * N; y++)
                            for (let x = 0; x < N; x++)
                                if (maxh < this.map[l][y][x].h)
                                    maxh = this.map[l][y][x].h;
                    if (maxh < this.nord.h)
                        maxh = this.nord.h;
                    if (maxh < this.south.h)
                        maxh = this.south.h;
                    if (maxh == 0)
                        maxh = 1;

                    // Нормируем высоты, чтобы минимальная была coresize, а максимальная была 1.0.
                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * N; y++)
                            for (let x = 0; x < N; x++)
                                this.map[l][y][x].h = coresize + this.map[l][y][x].h / maxh * (1 - coresize);
                    this.nord.h = coresize + this.nord.h / maxh * (1 - coresize);
                    this.south.h = coresize + this.south.h / maxh * (1 - coresize);
                }

                /** Заполняет узлы информацией о соседних узлах.
                 * У каждого узла появляется массив neighbors, сождержащий 5 или 6 указателей на соседние с ним узлы. */
                fillNeighbors() {
                    const N = this.N;
                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * N; y++)
                            for (let x = 0; x < N; x++) {
                                const neighbors = [];
                                neighbors.push(this.byCoords(l, y + 1, x));
                                neighbors.push(this.byCoords(l, y + 1, x + 1));
                                neighbors.push(this.byCoords(l, y, x + 1));
                                neighbors.push(this.byCoords(l, y - 1, x));
                                neighbors.push(this.byCoords(l, y - 1, x - 1));
                                neighbors.push(this.byCoords(l, y, x - 1));
                                this.map[l][y][x].neighbors = delDupes(neighbors);
                            }
                    this.nord.neighbors = [];
                    for (let l = 4; l >= 0; l--)
                        this.nord.neighbors.push(this.byCoords(l, 2 * N - 1, 0));
                    this.south.neighbors = [];
                    for (let l = 0; l < 5; l++)
                        this.south.neighbors.push(this.byCoords(l, 0, N - 1));

                    /** Удаляет дубли из массива, сохраняя порядок элементов */
                    function delDupes(arr) {
                        const res = [];
                        for (let i = 0; i < arr.length; i++)
                            if (i == 0 || arr[i] != arr[i - 1])
                                res.push(arr[i]);
                        if (res[0] == res[res.length - 1])
                            res.pop();
                        return res;
                    }
                }

                /** Добавляет каждому узлу строку id, идентификатор.
                 * Используется для отладки. */
                fillIds() {
                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * this.N; y++)
                            for (let x = 0; x < this.N; x++)
                                this.map[l][y][x].id = `l=${l},y=${y},x=${x}`;
                    this.nord.id = 'nord';
                    this.south.id = 'south';
                }

                fillGeoCoords() {
                    for (let l = 0; l < 5; l++)
                        for (let y = 0; y < 2 * this.N; y++)
                            for (let x = 0; x < this.N; x++) {
                                const node = this.map[l][y][x];
                                const coord = Map.geoPos(this.N, l, y, x);
                                node.lat = coord.lat;
                                node.lon = coord.lon;
                            }
                    this.nord.lat = Math.PI / 2;
                    this.nord.lon = 0;
                    this.south.lat = -Math.PI / 2;
                    this.south.lon = 0;
                }
            }

            class Seed {
                random() {
                    var res = [];
                    for (let i = 0; i < 10; i++)
                        res.push(rnd());
                    this.seed = res;

                    /** Возвращает случайный ненулевой вектор в сфере единичного радиуса */
                    function rnd() {
                        while (true) {
                            const x = Math.random() * 2 - 1;
                            const y = Math.random() * 2 - 1;
                            const z = Math.random() * 2 - 1;
                            const res = vec3.fromValues(x, y, z);
                            const l = vec3.length(res);
                            if (0.5 < l && l <= 1)
                                return res;
                        }
                    }
                }

                height(x, y, z) {
                    let h = 0;
                    const v = vec3.fromValues(x, y, z);
                    for (let i = 0; i < this.seed.length; i++) {
                        const l = vec3.length(this.seed[i]);
                        vec3.scale(v, v, l);
                        const d = vec3.sqrDist(this.seed[i], v);
                        h += 1 / (l * d + 0.02); // + на всякий случай, чтобы не было 1/0.
                    }
                    return h;
                }
            }

            $("p.error").remove();

            $(".resizable").resizable({
                stop: function () {
                    this.querySelector("canvas")?.frame?.onresize();
                }
            });
            new Frame1();
            new Frame2();
            new Frame3();
            new Frame4();

            /** Возвращает 3D координаты из географических, высота равна 1.0.
             * @param {number} lat
             * @param {number} lon
             */
            function geoTo3D(lat, lon) {
                return vec3.fromValues(
                    Math.cos(lat) * Math.cos(lon),
                    Math.sin(lat),
                    Math.cos(lat) * Math.sin(lon)
                );
            }

            /** Возвращает массив из случайных векторов vec3, на основе которого генерируется поверхность */
            function randomSeed() {
                var res = [];
                for (let i = 0; i < 10; i++)
                    res.push(rnd());
                return res;
            }
        }
    </script>
    <style>
        p.error {
            color: red;
        }
        label {
            display: block;
        }
    </style>
</head>
<body onload="main()">
    <h1>Гексагональная сетка</h1>
    <p>Далее размещены материалы к статье <a href="#">«Гексагональная сетка для игр с круглой Землей»</a>.</p>

    <p>Цилиндр на сфере:</p>
    <label><input type="checkbox" id="cb_frame4" />Вращение</label>
    <label><input type="checkbox" id="cb_shapes4" checked />Сетка</label>
    <input id="new4" type="button" value="Случайная" />
    <label>Делитель (1–32)<input type="number" id="divider4" min="1" max="32" value="1"></label>
    <label>Минимальная высота (0.1–1)<input type="number" id="height4" step="0.1" min="0.1" max="1" value="1.0"></label>
    <p class="error">Браузер не поддерживает Javascript. Работа программы невозможна.</p>
    <canvas id="glcanvas4" class="resizable" width="640" height="480"></canvas>

    <p>Куб на сфере:</p>
    <label><input type="checkbox" id="cb_frame3" />Вращение</label>
    <label><input type="checkbox" id="cb_shapes3" checked />Сетка</label>
    <input id="new3" type="button" value="Случайная" />
    <label>Делитель (1–32)<input type="number" id="divider3" min="1" max="32" value="1"></label>
    <label>Минимальная высота (0.1–1)<input type="number" id="height3" step="0.1" min="0.1" max="1" value="1.0"></label>
    <canvas id="glcanvas3" class="resizable" width="640" height="480"></canvas>

    <p>Икосаэдр:</p>
    <label><input type="checkbox" id="cb_frame1" />Вращение</label>
    <label><input type="checkbox" id="cb_shapes1" checked />Сетка</label>
    <input id="new1" type="button" value="Случайная" />
    <label>Делитель (1–32)<input type="number" id="divider1" min="1" max="32" value="1"></label>
    <label>Минимальная высота (0.1–1)<input type="number" id="height1" step="0.1" min="0.1" max="1" value="1.0"></label>
    <canvas id="glcanvas1" class="resizable" width="640" height="480"></canvas>

    <p>Многогранник Гольдберга:</p>
    <label><input type="checkbox" id="cb_frame2" />Вращение</label>
    <label><input type="checkbox" id="cb_shapes2" checked />Сетка</label>
    <input id="new2" type="button" value="Случайная" />
    <label>Делитель (1–32)<input type="number" id="divider2" min="1" max="32" value="1"></label>
    <label>Минимальная высота (0.1–1)<input type="number" id="height2" step="0.1" min="0.1" max="1" value="1.0"></label>
    <label><input type="checkbox" id="cb_water2" /></label>
    <label>Вода (0–1)<input type="number" id="water2" step="0.1" min="0" max="1" value="1.0"></label>
    <canvas id="glcanvas2" class="resizable" width="640" height="480"></canvas>

    <p>Картинки к статье, кстати, в векторном виде.</p>
    <div>
        <svg width="300" height="200" viewBox="0 0 51 51">
            <g fill="none" stroke="black">
                <polyline points="10,0 20,10 30,10 40,0" />
                <polyline points="0,20 10,20 20,10 30,10 40,20 50,20 60,10" />
                <polyline points="0,20 10,20 20,30 30,30 40,20 50,20 60,30" />
                <polyline points="0,40 10,40 20,30 30,30 40,40 50,40 60,30" />
                <polyline points="0,40 10,40 20,50 30,50 40,40 50,40 60,50" />
            </g>
        </svg>
    </div>
    <div>
        <svg width="400" height="300" viewBox="-1 -1 115 70">
            <g transform="matrix(1 2 1 -2 0 40)" id="spart1">
                <polyline fill="none" stroke="black" stroke-width="0.5" points="0,0 10,0 10,20 0,20 0,0" />
                <polyline fill="none" stroke="#888" stroke-width="0.1" points="0,0 10,10 0,10 10,20" />
            </g>
            <use xlink:href="#spart1" x="20" y="0" />
            <use xlink:href="#spart1" x="40" y="0" />
            <use xlink:href="#spart1" x="60" y="0" />
            <use xlink:href="#spart1" x="80" y="0" />
        </svg>
    </div>
    <div>
        <svg width="400" height="300" viewBox="-1 -1 115 70">
            <g transform="matrix(1 2 1 -2 0 40)" id="spart2">
                <polyline fill="none" stroke="black" stroke-width="0.5" points="0,0 10,0 10,20 0,20 0,0" />
                <polyline fill="none" stroke="#888" stroke-width="0.1" points="0,0 10,10 0,10 10,20" />
                <polyline fill="none" stroke="#888" stroke-width="0.1" points="5,0 10,5 0,5 10,15 0,15 5,20 5,0" />
            </g>
            <use xlink:href="#spart2" x="20" y="0" />
            <use xlink:href="#spart2" x="40" y="0" />
            <use xlink:href="#spart2" x="60" y="0" />
            <use xlink:href="#spart2" x="80" y="0" />
        </svg>
    </div>
    <div>
        <svg width="400" height="300" viewBox="-1 -1 130 70">
            <style>
                text {
                    font-size: 5px;
                }
            </style>
            <use xlink:href="#spart2" x="10" y="10" />
            <use xlink:href="#spart2" x="30" y="10" />
            <use xlink:href="#spart2" x="50" y="10" />
            <use xlink:href="#spart2" x="70" y="10" />
            <use xlink:href="#spart2" x="90" y="10" />
            <g fill="none" stroke-width="0.5">
                <polyline stroke="#00F" points="10,40 125,40 122,37 125,40, 122,43" />
                <polyline stroke="#00F" points="10,75 10,0 7,3 10,0 13,3" />
                <polyline stroke="#888" points="10,10 125,10" />
                <polyline stroke="#888" points="10,30 125,30" />
                <polyline stroke="#888" points="10,50 125,50" />
                <polyline stroke="#888" points="10,70 125,70" />
                <polyline stroke="#F80" points="50,0 50,10 60,30 60,80" />
                <polyline stroke="#F80" points="70,0 70,10 60,30" />
                <polyline stroke="#F80" points="90,0 90,50 100,70 100,80" />
                <polyline stroke="#F80" points="110,0 110,50 100,70 100,80" />
            </g>
            <text x="2" y="10">90°</text>
            <text x="2" y="30">30°</text>
            <text x="4" y="40">0°</text>
            <text x="0" y="50">-30°</text>
            <text x="0" y="70">-90°</text>
            <text x="60" y="75" style="fill: #840">180°</text>
            <text x="90" y="75" style="fill: #840">288°</text>
            <text x="101" y="75" style="fill: #840">360°</text>
        </svg>
    </div>
    <div>
        <svg width="500" height="250" viewBox="0 -7 100 60">
            <style>
                text {
                    font-size: 5px;
                }

                circle.dot {
                    fill: white;
                    stroke: black;
                    stroke-width: 0.5px;
                }
            </style>
            <g id="spart3">
                <polyline fill="none" stroke="#888" stroke-width="0.5" points="
                      5,40 20,25 0,25 20,5 0,5 5,0 5,40
                      10,40 20,30 0,30 20,10 0,10 10,0 10,40
                      15,40 20,35 0,35 20,15 0,15 15,0 15,40
                      0,40 20,20 0,20 20,0" />
                <polyline fill="none" stroke="black" points="0,0 20,0 20,40 0,40 0,0" />
                <circle cx="0" cy="0" r="0.8" class="dot" />
                <circle cx="5" cy="0" r="0.8" class="dot" />
                <circle cx="10" cy="0" r="0.8" class="dot" />
                <circle cx="15" cy="0" r="0.8" class="dot" />
                <circle cx="20" cy="0" r="0.8" class="dot" />
                <circle cx="20" cy="5" r="0.8" class="dot" />
                <circle cx="20" cy="10" r="0.8" class="dot" />
                <circle cx="20" cy="15" r="0.8" class="dot" />
                <circle cx="20" cy="20" r="0.8" class="dot" />
                <circle cx="20" cy="25" r="0.8" class="dot" />
                <circle cx="20" cy="30" r="0.8" class="dot" />
                <circle cx="20" cy="35" r="0.8" class="dot" />
                <circle cx="20" cy="40" r="0.8" class="dot" />
                <text x="-1" y="45">0</text>
                <text x="4" y="45">1</text>
                <text x="9" y="45">2</text>
                <text x="14" y="45">3</text>
                <text x="19" y="45" style="fill: #888">4</text>
                <text x="-5" y="42">0</text>
                <text x="-5" y="37">1</text>
                <text x="-5" y="32">2</text>
                <text x="-5" y="27">3</text>
                <text x="-5" y="22">4</text>
                <text x="-5" y="17">5</text>
                <text x="-5" y="12">6</text>
                <text x="-5" y="7">7</text>
                <text x="-5" y="2" style="fill: #888">8</text>
            </g>
            <text x="9" y="50">x</text>
            <text x="-10" y="22">y</text>
            <text x="7" y="-2">r=0</text>
            <text x="37" y="-2">r=1</text>
            <text x="87" y="-2">r=4</text>
            <text x="60" y="22">…</text>
            <use xlink:href="#spart3" x="30" y="00" />
            <use xlink:href="#spart3" x="80" y="00" />
        </svg>
    </div>
    <div>
        <svg width="500" height="300" viewBox="0 -1 80 84">
            <defs>
                <marker id="triangle"
                        viewBox="0 0 10 10"
                        refX="5"
                        refY="5"
                        markerUnits="strokeWidth"
                        markerWidth="5"
                        markerHeight="5"
                        orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="context-fill" />
                </marker>
            </defs>
            <g id="spart4">
                <polyline fill="none" stroke="#888" stroke-width="0.5" points="
                      10,80 40,50 0,50 40,10 0,10 10,0 10,80
                      20,80 40,60 0,60 40,20 0,20 20,0 20,80
                      30,80 40,70 0,70 40,30 0,30 30,0 30,80
                      0,80 40,40 0,40 40,0" />
                <polyline fill="none" stroke="black" stroke-width="1" points="0,0 40,0 40,80 0,80 0,0" />
                <g fill="red" stroke="red" marker-start="url(#triangle)" marker-end="url(#triangle)">
                    <polyline points="10,40 30,40" />
                    <polyline points="20,30 20,50" />
                    <polyline points="10,50 30,30" />
                </g>
            </g>
            <use xlink:href="#spart4" x="0" y="0" transform="matrix(0.4 0.6 -0.4 0.6 80 4)" />
        </svg>
    </div>
    <div>
        <svg width="800" height="400" viewBox="0 -1 100 100">
            <defs>
                <marker id="circle"
                        markerWidth="4"
                        markerHeight="4"
                        refX="2"
                        refY="2"
                        markerUnits="strokeWidth">
                    <circle cx="2" cy="2" r="2" stroke="context-stroke" fill="context-fill" />
                </marker>
            </defs>
            <g transform="matrix(0.8 0.5 -0.1 0.6 -20 5)">
                <g id="spart5">
                    <polyline fill="none" stroke="#888" stroke-width="0.5" points="
                      10,80 40,50 0,50 40,10 0,10 10,0 10,80
                      20,80 40,60 0,60 40,20 0,20 20,0 20,80
                      30,80 40,70 0,70 40,30 0,30 30,0 30,80
                      0,80 40,40 0,40 40,0" />
                    <polyline fill="none" stroke="black" stroke-width="1" points="0,0 40,0 40,80 0,80 0,0" />
                </g>
                <use xlink:href="#spart5" x="60" y="-40" />
                <g fill="red" stroke="red" marker-start="url(#triangle)" marker-end="url(#triangle)">
                    <polyline points="50,30 70,30" />
                    <polyline points="60,20 60,40" />
                    <polyline points="50,40 70,20" />
                </g>

                <g fill="red" stroke="red" stroke-width="0.7" marker-start="url(#circle)" marker-end="url(#triangle)">
                    <polyline points="50,40 30,40" />
                    <polyline points="50,30 30,30" />
                </g>
            </g>
        </svg>
    </div>
    <div>
        <svg width="800" height="400" viewBox="0 -1 100 100">
            <defs>
                <marker id="circle"
                        markerWidth="4"
                        markerHeight="4"
                        refX="2"
                        refY="2"
                        markerUnits="strokeWidth">
                    <circle cx="2" cy="2" r="2" stroke="context-stroke" fill="context-fill" />
                </marker>
            </defs>
            <g transform="matrix(0.8 0.5 -0.1 0.6 -20 5)">
                <g id="spart5">
                    <polyline fill="none" stroke="#888" stroke-width="0.5" points="
                      10,80 40,50 0,50 40,10 0,10 10,0 10,80
                      20,80 40,60 0,60 40,20 0,20 20,0 20,80
                      30,80 40,70 0,70 40,30 0,30 30,0 30,80
                      0,80 40,40 0,40 40,0" />
                    <polyline fill="none" stroke="black" stroke-width="1" points="0,0 40,0 40,80 0,80 0,0" />
                </g>
                <use xlink:href="#spart5" x="60" y="-40" />
                <use xlink:href="#spart5" x="120" y="-80" />

                <g fill="red" stroke="red" stroke-width="0.7" marker-start="url(#circle)" marker-end="url(#triangle)">
                    <polyline points="50,50 30,50" fill="blue" stroke="blue" />
                    <polyline points="50,40 30,40" />
                    <polyline points="50,30 30,30" />
                    <polyline points="50,20 30,20" />
                    <polyline points="50,10 30,10" fill="blue" stroke="blue" />
                    <polyline points="50,0 30,10" fill="blue" stroke="blue" />
                    <polyline points="50,-10 20,10" />
                    <polyline points="50,-20 10,10" />
                    <polyline points="50,-30 00,10" />
                    <polyline points="60,-40 60,-50" fill="green" stroke="green" />
                    <polyline points="70,-40 120,-70" />
                    <polyline points="80,-40 120,-60" />
                    <polyline points="90,-40 120,-50" />
                    <polyline points="100,-40 120,-40" />
                    <polyline points="100,-30 120,-30" />
                    <polyline points="100,-20 120,-20" />
                    <polyline points="100,-10 120,-10" />
                    <polyline points="100,0 120,0" />
                    <polyline points="100,10 130,0" />
                    <polyline points="100,20 140,0" />
                    <polyline points="100,30 150,0" />
                    <polyline points="100,40 110,40" fill="green" stroke="green" />
                    <polyline points="90,50 30,80" />
                    <polyline points="80,50 30,70" />
                    <polyline points="70,50 30,60" />
                    <polyline points="60,50 30,50" fill="blue" stroke="blue" />
                </g>
            </g>
            <text x="31" y="4">nord</text>
            <text x="66" y="86">south</text>
        </svg>
    </div>
    <div>
        <svg width="300" height="200" viewBox="0 0 51 51">
            <g fill="none" stroke="black">
                <polyline points="10,0 20,10 30,10 40,0" />
                <polyline points="0,20 10,20 20,10 30,10 40,20 50,20" />
                <polyline points="0,20 10,20 20,30 30,30 40,20 50,20" />
                <polyline points="10,40 20,30 30,30 40,40" />
            </g>
            <g stroke="blue" fill="blue" marker-start="url(#circle)" marker-end="url(#circle)">
                <circle cx="5" cy="30" r="2"></circle>
                <circle cx="5" cy="10" r="2"></circle>
                <circle cx="45" cy="10" r="2"></circle>
                <circle cx="45" cy="30" r="2"></circle>
                <circle cx="25" cy="3" r="2"></circle>
                <circle cx="25" cy="20" r="2"></circle>
                <circle cx="25" cy="40" r="2"></circle>

            </g>
        </svg>
    </div>
</body>
</html>
